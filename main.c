#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <time.h>

/* put trojan in a section called ".trojan-section" */
void trojan(void) __attribute__((section(".trojan-section")));
void trojan(){
  asm volatile (
    // Do malicious stuff >:D
    "addi a0,  a0, 69 \n"
    "lui  a1, 0x69420 \n"

    // Jump back at trigger point
    // May need some additionnal work for further jump
    // 0x200038 is the chosen trigger address.
    "li  x31, 0x200038\n"
    "jalr x0, x31, 0\n"
  );
  printf("I'm evil!\n");  // Will never be reached
}


// Actual benchmark: here, runs dijsktra algorithm
// Generated by ChatGPT. The correctness of the algorithm isn't important
// as long as it does stuff.

#define MAX_NODES 6  // Graph size
#define MAX_WEIGHT 10

// Find vertex with minimum distance
int minDistance(int dist[], int visited[], int n) {
    int min = INT_MAX, min_index = -1;
    for (int v = 0; v < n; v++) {
        if (!visited[v] && dist[v] <= min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}

// put this function in a section called ".target". Make target address selection easier.
void dijkstra(int graph[MAX_NODES][MAX_NODES], int n, int src) __attribute__((section(".target")));

// Dijkstra's algorithm
void dijkstra(int graph[MAX_NODES][MAX_NODES], int n, int src) {
    int dist[MAX_NODES];
    int visited[MAX_NODES] = {0};

    for (int i = 0; i < n; i++)
        dist[i] = INT_MAX;
    dist[src] = 0;

    for (int count = 0; count < n - 1; count++) {
        int u = minDistance(dist, visited, n);
        if (u == -1) break;
        visited[u] = 1;

        for (int v = 0; v < n; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX
                && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }
}

// Generate random weighted graph
void generateRandomGraph(int graph[MAX_NODES][MAX_NODES], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j)
                graph[i][j] = 0;
            else
                graph[i][j] = (rand() % 2) ? (1 + rand() % MAX_WEIGHT) : 0;
        }
    }
}

int main() {
    srand(time(NULL));

    int graph[MAX_NODES][MAX_NODES];
    int n = MAX_NODES;

    while (1) {
        generateRandomGraph(graph, n);
        dijkstra(graph, n, 0);  // Run from node 0
    }

    return 0;
}
